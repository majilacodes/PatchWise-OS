import os
import requests
import time
from datetime import datetime, timedelta

from langchain.chains import create_history_aware_retriever, create_retrieval_chain
from langchain.chains.combine_documents import create_stuff_documents_chain
from langchain_community.vectorstores import Chroma
from langchain_core.documents import Document
from langchain_core.prompts import ChatPromptTemplate, MessagesPlaceholder

from modules.system_info import collect_system_info

def fetch_vulnerabilities(persistent_directory, embeddings, nvd_api_key=""):
    """Fetch latest OS vulnerabilities from NVD database"""
    # Get current system info to use for fetching relevant vulnerabilities
    system_info = collect_system_info()
    os_name = system_info['os']['name'].lower()
    
    # Map internal OS names to CVE searchable terms
    os_search_terms = {
        "windows": "windows",
        "linux": "linux",
        "darwin": "macos"
    }
    
    search_term = os_search_terms.get(os_name, os_name)
    
    # Calculate the date 30 days ago (to get recent vulnerabilities)
    thirty_days_ago = (datetime.now() - timedelta(days=30)).strftime("%Y-%m-%dT%H:%M:%S.000")
    current_time = datetime.now().strftime("%Y-%m-%dT%H:%M:%S.000")
    
    # Set up the NVD API request
    url = "https://services.nvd.nist.gov/rest/json/cves/2.0"
    params = {
        "keywordSearch": search_term,
        "pubStartDate": thirty_days_ago,
        "pubEndDate": current_time
    }
    
    # Only add API key header if it exists in environment variables
    headers = {}
    if nvd_api_key and nvd_api_key.strip():
        headers["apiKey"] = nvd_api_key
    
    try:
        response = requests.get(url, params=params, headers=headers)
        # Add a delay to respect rate limits when not using API key
        if not nvd_api_key or not nvd_api_key.strip():
            time.sleep(6)  # NVD has a rate limit of 10 requests per minute without API key
            
        if response.status_code == 200:
            vulnerabilities = response.json().get('vulnerabilities', [])
            
            # Convert to documents and store in vector database
            documents = []
            for vuln in vulnerabilities:
                cve = vuln.get('cve', {})
                cve_id = cve.get('id', 'Unknown')
                description = cve.get('descriptions', [{}])[0].get('value', 'No description')
                
                # Get metrics if available
                metrics = cve.get('metrics', {})
                cvss_data = metrics.get('cvssMetricV31', [{}])[0] if 'cvssMetricV31' in metrics else metrics.get('cvssMetricV2', [{}])[0] if 'cvssMetricV2' in metrics else {}
                
                base_score = cvss_data.get('cvssData', {}).get('baseScore', 'N/A') if cvss_data else 'N/A'
                severity = cvss_data.get('cvssData', {}).get('baseSeverity', 'N/A') if cvss_data else 'N/A'
                
                # Create the document
                doc_content = f"CVE ID: {cve_id}\nSeverity: {severity}\nBase Score: {base_score}\nDescription: {description}"
                documents.append(Document(
                    page_content=doc_content,
                    metadata={
                        "source": "nvd",
                        "cve_id": cve_id,
                        "severity": severity,
                        "base_score": base_score,
                        "timestamp": datetime.now().strftime("%Y-%m-%d %H:%M:%S")
                    }
                ))
            
            # Add to vector database
            if documents:
                db = Chroma(persist_directory=persistent_directory, embedding_function=embeddings)
                db.add_documents(documents)
                db.persist()
            
            return vulnerabilities
        else:
            return {"error": f"API returned status code {response.status_code}"}
    except Exception as e:
        return {"error": str(e)}

def setup_rag_chain(persistent_directory, embeddings, llm):
    """Set up the RAG chain for vulnerability analysis"""
    # Load the vector store
    db = Chroma(persist_directory=persistent_directory, embedding_function=embeddings)
    
    # Create a retriever
    retriever = db.as_retriever(
        search_type="similarity",
        search_kwargs={"k": 5},
    )
    
    # Contextualize question prompt
    contextualize_q_system_prompt = (
        "Given a chat history and the latest user question "
        "which might reference context in the chat history, "
        "formulate a standalone question which can be understood "
        "without the chat history. Do NOT answer the question, just "
        "reformulate it if needed and otherwise return it as is."
    )
    
    contextualize_q_prompt = ChatPromptTemplate.from_messages(
        [
            ("system", contextualize_q_system_prompt),
            MessagesPlaceholder("chat_history"),
            ("human", "{input}"),
        ]
    )
    
    # Create a history-aware retriever
    history_aware_retriever = create_history_aware_retriever(
        llm, retriever, contextualize_q_prompt
    )
    
    # Answer question prompt
    qa_system_prompt = (
        "You are a cybersecurity expert specializing in vulnerability assessment and mitigation. "
        "Use the following pieces of retrieved context to analyze vulnerabilities and their applicability "
        "to the user's system. When asked about vulnerabilities:"
        "\n\n"
        "1. Identify if the vulnerability applies to the user's system configuration"
        "2. Provide detailed but concise mitigation steps specific to the user's OS"
        "3. Explain the severity and potential impact of the vulnerability"
        "4. Include specific commands or actions the user should take"
        "\n\n"
        "If you don't have enough information, ask for specific details about the system. "
        "If a vulnerability doesn't apply to the user's system, clearly state this fact."
        "\n\n"
        "{context}"
    )
    
    qa_prompt = ChatPromptTemplate.from_messages(
        [
            ("system", qa_system_prompt),
            MessagesPlaceholder("chat_history"),
            ("human", "{input}"),
        ]
    )
    
    # Create a chain to combine documents for question answering
    question_answer_chain = create_stuff_documents_chain(llm, qa_prompt)
    
    # Create the full retrieval chain
    rag_chain = create_retrieval_chain(history_aware_retriever, question_answer_chain)
    
    return rag_chain
